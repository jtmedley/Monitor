//Ran for 5 days before I turned it off. Switchd patients multiple times in those 5 days with box remaining on entire time no problem. Only difference between this and preious test was scope function was commented out in this test.
//40hrqtst Faild
//todo: check int unsigned long if it is real.
//None of the leds were turned on after it ran from 11/3/17 5pm room 483 till 11/6/17 11:52 am. 4 & 3/4 days. Seems to run correctly. Only real change from main was .02 s to .04s sendcommand.
#include "mbed.h"
#include "mbed_genie.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include "SDFileSystem.h"
//siz of int is 4. I am fin. It dont oerflow.
//mbd siz of int mak sure doesnt oerflow
//#define DEBUG 1
//Going to standby breaks it and it can't fix itself. Currently running 30 min stress test.
//todo check if creation worked catch throw.

//todo: All the screen text messages and error codes.
//Graphing and writing seem good when they work tho.
//todo: After reinserting card it has started to fail again. Fix this by combinind whiteresult into white right rather than having them separate. The issue is it will mount in whiteresult, then fail to mount in whitewrite. I thought this would never occur but it does now. Seems to start occurring after calling transfer_file().

//MRN Keyboard Works. Now need to Integrate.
//Added detatch in mbed_genie to fix interupt vector sharing issue with vent. have yet to test integration tho.
//lcd4d.genieWriteObject(GENIE_OBJ_FORM,8,0); //transfer complete. safe to remove 20 seconds
//Trend now works. But the time axis is definitely off. Will need to reprogram that on screen side.
//12 Hour SCOPE SUPPORTS 74 POINTS, Should be 72
//1 HOUR SCOPE SUPPORTS 26 Points, Should be 24
//24 Hour suppots 108*? or 109. Should be 96.
//Inserted Multiple printfs throughout the code. Still can not fix screen flicker. Dlee suggests possibly pins are using the same timer and thats why its failing. Look at the pins im using and check their alternate functions to make sure there is no overlap. may fix but no promise
//Flickers sometimes at mounting. Sometimes at file opening. Always at file writing.
//Everything Works. Updated Rx_interrupt. Had offby1 errors. Now can remove from vent and put back and program will still run. Got rid of some old junk and did general cleanup. Throws away data if doesn't look good with new bool wentwell.
//ALL WORKING AS INTENDED WITH SD AND PB. NEED TO ADD FIXES TO ACCOUNT FOR REMOVAL OF RS232 DURING RUNTIME THO. SCREEN REMOUNTS WHEN MOUNTING SD, FIXABLE?
//Inserting changes from whatfucksd823_istherehope to hopefully fix storetomount.
//STORETOFILEWHITE WONT MOUNT. BUT WHITE MOUNTS EVERYWHEREELS. FIGURE OUT WHY BC CANT WRITE VENT DATA TO INTERNAL UNTIL THEN.
//DID FIX GENERAL FILE WRITING THO.. LIT CHANGED NOTHING BUT A PRINTF AND IT STARTED WORKING. UNCLEAR WHY.
//todo add back EIP check to parse and make ventcurvebuffer slightly bigger than 4096*9 incase someone quickly plugs and unplugs cable back to vent.
//Crashes if write to file but otherwise works as intended. Can even remove cord midway and it will fix itself
//Running storetofile at end crashes program. Otherwise everything else works.
//todo: add the other non fft channel to file and internal to sd and transfer to external.
//File writing works but need to do stuff below.
//todo: Change storage to internal sd rather than external. Than transfer to external.
//write the 4096 point curve channels to file as well
//Missing sdlibrary so I cloned ashfinaledits_topherstart_7_28 to parse_fft_filelib. then copy pasted code. and deleted 4dgenie library.
//Put FFT in function process data. Works.
//Changed parse to len-8. Added fft in main. Seems to work.
//Tested and it seems to work as of 8/17 scratch. Cleaned up functions and am now moving on to parse.
//Rewrote rx interrupt according to todo to have bufferselect outside and check buffersizes. wanted to test but online compiler heavy load so couldnt.
//Works but there is something weird with strlen(readsettings returning 14 instead of 8);
//todo 0x62. '6', '2'. try send 0x36 followed by 0x32. WORKS BUTBUTBUT: 0x6b send 0x36 0x62 does not work.
//mbed has all c++ libraries. do a convert (sprintf %2d , 0x62 formats binary into two characters) to get ASCII.
//dont put const char in argument if they are global.
int settingsERcnt = 0; //:%d line 272 myled2
int resppeepconversion = 0; //:%d myled1
int parseconversion = 0; //:%d GENIE_OBJ_USER_LED
int wellintrpt = 0;
int commcheckcount = 0;
Serial pc(USBTX, USBRX);
Serial vent(PD_5, PD_6);
Mbed4dGenie lcd4d(PC_12,PD_2,PC_9);
DigitalOut myled1(LED1);
DigitalOut myled2(LED2);
DigitalOut myled3(LED3);

DigitalOut whitesd(PA_4);
DigitalOut bluesd(PB_4);
DigitalIn pb_exportcontrol(PF_2); //1 dont export, 0 Export. Changed to 1 if button pressed
#define fftsize 4096
#define rawdatasize (fftsize * 9) //36864
#define settingssize 200
volatile char rawventdata_curve[rawdatasize]; //bufferselect 1
volatile char rawventdata_settings[settingssize]; //bufferselect 2
volatile int interruptdatacount_curve = 0;
volatile int interruptdatacount_settings = 0;
volatile int ib_datacollectionwentwell = 1;
volatile int bufferselect = 0; //shouldn't be volatile since only changes in functions not interrupt?
//buffer select == 0, !=1 && !=2: Grabs data from vent but does not store anywhere. Print to screen optional.
//bufferselect == 1: Writes data from Rx_interrupt to rawventdata_curve
//bufferselect == 2: Writes data from Rx_interrupt to rawventdata_settings
//Everything Else: Do nothing

double parsedchannelzero[fftsize];
double parsedchanneltwo[fftsize];
double processedchannelzeroNEG[fftsize];
double processedchannelzeroPOS[fftsize];
double processedchanneltwo[fftsize];

int i_resprate; //For calculating H1DC
int i_PEEP; //For Pressure FFT;
char s_MRN[]="          "; //10 spaces for gathering mrn from screen and writing to file.
char s_DEBUG[]="          "; //10 spaces for gathering mrn from screen and writing to file.
//int setgaugetemptest = 15;
int str2int(int *out, char *s, int base)
{
    char *end;
    if (s[0] == '\0' || isspace((unsigned char) s[0])) {
        return 1; //STR2INT_INCONVERTIBLE
    }
    errno = 0;
    long l = strtol(s, &end, base);
    /* Both checks are needed because INT_MAX == LONG_MAX is possible. */
    if (l > INT_MAX || (errno == ERANGE && l == LONG_MAX)) {
        return 2; //STR2INT_OVERFLOW
    }
    if (l < INT_MIN || (errno == ERANGE && l == LONG_MIN)) {
        return 3; //STR2INT_UNDERFLOW
    }
    if (*end != '\0') {
        return 4;//STR2INT_INCONVERTIBLE;
    }
    *out = l;
    return 0;
}

int parserawdata(void)
{
    //todo: is it better to just throw away the entire 2.5 minutes of data if something goes wrong?
#ifdef DEBUG
    pc.printf("Parse raw vent data begin: \n");
#endif
    int len = rawdatasize;
    int count = 0;
    char temp1[] = "AAAA"; //was defined as read only (pointer to string literal) before topher scratch. todo
    char temp2[] = "BBBB";
    int tempint1 = 0;
    int tempint2 = 0;
    double scaling = 0;
    for(int i = 0; (i<(len-8)) && (count<4096); i++) { //for each character in the array until last data point.
        if(*(rawventdata_curve+i) == 'E' || *(rawventdata_curve+i) == 'I' || rawventdata_curve[i] == 'P') { //find the beginning of the read
            temp1[0] = *(rawventdata_curve+i+1);
            temp1[1] = *(rawventdata_curve+i+2);
            temp1[2] = *(rawventdata_curve+i+3);
            temp1[3] = *(rawventdata_curve+i+4);

            temp2[0] = *(rawventdata_curve+i+5);
            temp2[1] = *(rawventdata_curve+i+6);
            temp2[2] = *(rawventdata_curve+i+7);
            temp2[3] = *(rawventdata_curve+i+8);

            //Now convert each channel to correct units by following formula
            //<value> = ((<raw_value>-2048)*4.883)/<scale_factor>
            //CH 00 Airway Flow Curve Scale factor : 5000 mV/l/s
            //CH 02 Airway Pressure Insp (curve): 50mV/cm H2O
            if((str2int(&tempint1, temp1, 10) == 0) && (str2int(&tempint2, temp2, 10) == 0)) {
                scaling = (double)((tempint1-2048)*4.883)*60.0/5000.0;
                parsedchannelzero[count] = scaling;
                scaling = (double)((tempint2-2048)*4.883)/50.0;
                parsedchanneltwo[count] = scaling;
                count++;
            } else {
                parseconversion++; //lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,0,1);
                return 1;
            }
        }
    }
#ifdef DEBUG
    pc.printf("Count: %d\n", count);
    pc.printf("Count: %d\n", count);
    pc.printf("Count: %d\n", count);
    pc.printf("Count: %d\n", count);
#endif
    return 0;
}

void sendcommand(const char command[], int lencommand)
{
    for(int i = 0; i < lencommand; i++) {
        vent.putc(command[i]); //change to vent put
        wait(.04); //Necessary. Delay of .0104 or shorter known to cause it to fail and spit garbage sometimes.
    }
}
volatile int ib_needmoredata = 0;
//use static for local variabls bc mmory orlay? suggstd. https://www.embedded.com/design/programming-languages-and-tools/4398340/Interrupts-short---simple--Variables--buffers---latencies
void Rx_Interrupt()
{
    char interrupttempchar;
    if(bufferselect == 1) {
        if((vent.readable()) && (interruptdatacount_curve < rawdatasize)) {
            interrupttempchar = vent.getc();
#ifdef DEBUG
            //pc.putc(interrupttempchar);
#endif
            if(interrupttempchar == 4) { // If EOT.
                ib_needmoredata = 1; //Since encapsulating if(interruptdatacount_curve < rawdatasize). Don't have enough data. Set flag in main that will Resend command for more data.
            } else { // Not EOT. Is therefore a point we want to save.
                rawventdata_curve[interruptdatacount_curve] = interrupttempchar;
                interruptdatacount_curve++;
            }
        } else if((vent.readable()) && (interruptdatacount_curve >= rawdatasize)) { //todo: If vent is still trying to send data even though we have enough. Grab it so it doesnt break but do nothing with it. Could happen if someone unplugs during runtime then replugs in and we end up requesting another 1024 points even though we already have 3900etc collected already.
            interrupttempchar = vent.getc(); //pc.putc(vent.getc());
#ifdef DEBUG
            pc.putc(interrupttempchar);
#endif
            if(interrupttempchar != 4) { // If not EOT
                //pc.putc(interrupttempchar);
                ib_datacollectionwentwell = 0; //set to 0 indicating bad data. Perhaps somone unplugged cable.
            }
        }
    } else if(bufferselect == 2) {
        if((vent.readable()) && (interruptdatacount_settings < settingssize)) {
            interrupttempchar = vent.getc();
            //pc.putc(interrupttempchar);
            rawventdata_settings[interruptdatacount_settings] = interrupttempchar;
            interruptdatacount_settings++;
        } else if((vent.readable()) && (interruptdatacount_settings >= settingssize)) {
            interrupttempchar = vent.getc(); //pc.putc(vent.getc());
#ifdef DEBUG
            //pc.putc(interrupttempchar);
#endif
        }
    } else { //all other buffer selects. Just grab it then drop it.
        if(vent.readable()) {
            interrupttempchar = vent.getc();
#ifdef DEBUG
            pc.putc(interrupttempchar);
#endif
        }
    }
}

void collectsettings(void)
{

#ifdef DEBUG
    pc.printf("Request settings: \n");
#endif
    int chckt = 0;
    int attempts = 0;
    ////// basic
    const char hello[] = {'H', 'O', 0x04};
    const char readtime[] = {'R', 'T', 0x04};

    int lenhello = 3;
    int lenreadtime = 3;
    // extended commands
    const char rcty[] = {'R', 'C', 'T', 'Y', '1', 'C', 0x04};
    const char readbreath[] = {'R', 'A', 'D', 'A', 'B', '5', '4', 0x04}; //read acquired data
    const char readsettings[] = {'R', 'A', 'D', 'A', 'S', '4', '5',0x04};
    const char breathchannelrevised[] = {'S','D','A','D','B','2','0','0','2','0','1','2','0','2','2','0','4','2','0','5','2','0','6','2','0','7','2','0','8','2','3','8','2','3','9','2','4','4','2','3','2','2','5','1','2','5','7','2','5','8','2','0','9','5','9',0x04};//works but channels 244 232 257 258 return 9999.
    //200MeasuredBreathFrequncy, 201ExpTidalVolume, 202InspTidalVolume, 204ExpMinuteVolume, 204PeakPressure, 206MeanAirwayPressure, 207PausePressure, 208EndExpPressure, 238I:E, 239InsufflationTime, 244Ti/Ttot, 232StaticCompliance, 251VentWorkofBreathing, 257%EDITriggerInNAVA, 258%CycloffinNAA, 209OxygenConc
    const char settingschannelrevised[] = {'S','D','A','D','S','3','0','9','3','1','0','3','2','3','3','0','0','3','3','4','3','0','5','3','0','6','3','0','8','3','3','3','7','7',0x04}; //works ch 306 returns 9999. 333 dont know what value means relative to vent.

    int lenrcty = 7;
    int lenreadbreath = 8;
    int lenreadsettings = 8;
    int lenbreathchannelrevised = 56;
    int lensettingschannelrevised = 35;

    char ch_resprate[] = "QQ";
    char ch_PEEP[] = "QQ";
    //Select settings buffer and start writing at index 0.
    do {
        chckt = 0;
        wait(.2); //todo: remove. probably unnecessarry. But just in case bc keeps crashing.
        bufferselect = 2;
        interruptdatacount_settings = 0;
        sendcommand(hello, lenhello); //900PCI<04>
        sendcommand(readtime, lenreadtime);// 2 digits each - year,month,day,hour,minute,second ex)170817135035
        sendcommand(rcty, lenrcty); //Servo-i029<04>
        sendcommand(breathchannelrevised, lenbreathchannelrevised); //*2A<04>
        sendcommand(settingschannelrevised, lensettingschannelrevised); //*2A<04>
        //pc.printf("interruptcount_settingsBEGIN: %d\n", interruptdatacount_settings); //39
        sendcommand(readbreath, lenreadbreath); //4 ASCII characters per channel followed by 2 char checksum at very end.
        //pc.printf("interruptcount_settingsMIDDLE: %d\n", interruptdatacount_settings); //106
        sendcommand(readsettings, lenreadsettings); ////4 ASCII characters per channel followed by 2 char checksum at end.
        int j = 0;
        while(interruptdatacount_settings < 145) {
            if(j >5) {
                break;
            }
            wait(1);
            j++;
        }
        //pc.printf("InterruptdataCount_settingsEND: %d\n", interruptdatacount_settings); //145
        ch_resprate[0] = rawventdata_settings[40];
        ch_resprate[1] = rawventdata_settings[41];
        ch_PEEP[0] = rawventdata_settings[68];
        ch_PEEP[1] = rawventdata_settings[69];
        for(int i = 0; i<145; i++) {
            if(rawventdata_settings[i] == 'E' && rawventdata_settings[i+1] == 'R') {
                settingsERcnt++; //myled2 = 1;
                chckt = 1;
            }
        }
        if((str2int(&i_resprate, ch_resprate, 10)!=0) && (str2int(&i_PEEP, ch_PEEP, 10)!=0)) {
            resppeepconversion++; //myled1 = 1;
        }
        attempts++;
        if(attempts >= 5) {
            myled1 = 1;
        }
    } while(chckt == 1 && attempts <5);
#ifdef DEBUG
    pc.printf("int resprate: %d\n", i_resprate);
    pc.printf("int PEEP: %d\n", i_PEEP);
    //pc.printf("float resprate: %f\n", (float)i_resprate);
    pc.printf("settingsbuffer: \n");
    for(int i = 0; i<interruptdatacount_settings; i++) {
        pc.printf("%c",rawventdata_settings[i]);
    }
#endif
}

void requestcurvedata(void)
{
#ifdef DEBUG
    pc.printf("Request data: \n");
#endif
    ////// basic
    const char hello[] = {'H', 'O', 0x04};
    const char cs[] = {'C', 'S', '0', '3', '2', 0x04};
    const char channels[] = {'D', 'C', '0', '0', '0', '2', 0x04};
    const char readcurve[] = {'R', 'C', '1', '0', '2', '4', '0', 0x04};
    int lenhello = 3;
    int lencs = 6;
    int lenchannels = 7;
    int lenreadcurve = 8;
    bufferselect = 0; //dont need to set interrupt data count if not writing to a buffer.
    ib_datacollectionwentwell = 1; //assume its working properly until proven otherwise.
    sendcommand(hello, lenhello);
    sendcommand(cs, lencs);
    sendcommand(channels, lenchannels);
    //Select curve buffer and start writing at index 0.
    wait(3);//todo added in volatilebuffer version. not sure if helps
    /*while(interruptdatacount_settings < 145) {
        if(j >5) {
            break;
        }
        wait(1);
        j++;
    }*/
    bufferselect = 1;
    interruptdatacount_curve = 0; //write to beginning of 4096*9 long buffer
    sendcommand(readcurve, lenreadcurve);
}


//FFT CODE
//todo change 4096 to fftsize
double real[4096];      //real data in and real answers out
double imag[4096];      //imag data in and imag answers out
//double output[4096];
const double pi = 3.14159265359;
const double ff = pi/-2048.0; //value used to calculate proper sin/cos values in butterfly
//you could speed the program up by pre-calculating sin and cos values at the start since they never change,
//It would speed the fft, but would also take more vector space for the sin/cos vectors. To do this include new global vectors sv and cv:
//double cv[2048],sv[2048]
//in main add the following startup code to fill the vectors once at startup:
//      for(i=0;i<2048;i++)
//      {
//          cv[i]=cos(ff*(double(i));
//          sv[i]=sin(ff*(double(i));
//      }
//then in butterfly:
//      replace CMult(&c1,&id1,c2,id2,cv,sv); with CMult(&c1,&id1,c2,id2,cv[tf],sv[tf]);
//      and remove double cv = cos(ff*(float)tf); and double sv = sin(ff*(float)tf);
// complex arithmetic routines result is in r+ir, two input values are a+ib and c+id
void CMult(double *r, double *ir, double a, double ib, double c, double id)
{
    *r = a*c-ib*id;
    *ir = a*id+ib*c;
}

void CAdd(double *r, double *ir, double a, double ib, double c, double id)
{
    *r = a+c;
    *ir = ib+id;
}

void CSub(double *r, double *ir, double a, double ib, double c, double id)
{
    *r = a-c;
    *ir = ib-id;
}

// bit reversal routine for numbers 0 to 4095; n is bit reversed over 12 bit field
int BitRev(int n)
{
    int i,r,m;
    m=n;            //hold input value
    r=0;            //resulting number
    for(i=0; i<12; i++) {   //12 bits covers 4096 numbers
        r=r>>1;     //shift result one from left
        if(m & 2048) r+= 2048;          //left shifted bits in m get right shifted in r
        m=m<<1;
    }
    return r;
}

//basic butterfly operation using above complex routines
void Butterfly(int n, int ofs, int tf)   //stage n, offset for stage, "twiddle factor" index
{
    //todo: assert n+ofs < 4096.?
    double a1,ib1,a2,ib2;
    double c1,id1,c2,id2;
    double cv = cos(ff*(float)tf);
    double sv = sin(ff*(float)tf);
    a1 = real[n];
    ib1 = imag[n];
    a2 = real[n+ofs];
    ib2 = imag[n+ofs];
    CAdd(&c1,&id1,a1,ib1,a2,ib2);
    real[n] = c1;
    imag[n] = id1;
    CSub(&c2,&id2,a1,ib1,a2,ib2);
    CMult(&c1,&id1,c2,id2,cv,sv);
    real[n+ofs]=c1;
    imag[n+ofs]=id1;
}

//fft algorithm uses butterfly from above, which uses complex arithmetic, etc.
void fft(void)
{

    //printf("Starting FFT...");
    int st, i, idx,tf,tf1;
    idx = 2048;             //start first round offset at 1/2 data vector
    tf1 = 0;                //starting twiddle factor
    for(st=0; st<12; st++) { //12 stages for a 4096 sample fft
        for(i=0; i<4096; i++) {
            if(!(i&idx)) {            //samples to perform butterfly on
                tf = i%idx;             //twiddle factor index is i mod idx
                Butterfly(i,idx,tf<<tf1); //butterfly with vector index i, stage index idx, tfactor index
            }
        }
        idx = idx>>1;                   //each stage divide idx by 2
        tf1++;                          //increment speed of sin/cos by mult tf by 2
    }
    //printf(" Done. \n");
}

int processdata(double *output)
{
    int i,n;
    double val;
    fft();          //perform fft

    for(i=0; i<4096; i++) {  //print out a few to see if it works
        n=BitRev(i);  //bit reverse to get the correct value for each frequency
        val = sqrt(real[n]*real[n]+imag[n]*imag[n])/4096.0;
        output[i] = val;
        //val is 4096 times too large - due to 4096 fft, so divide by that value
        //not doing that right now because can't write floats to sd card but should do so in future code
        //printf("freq:%d val:%f\n",i,val/4096.0);
    }

    // Find H1/DC
    float DC = output[0]; // DC component is just the very first value
    //printf("DC component: %f\n", DC);
    float RR = (float)i_resprate/60.0; // we will want to get this value from vent eventually, but for now I am counting peaks in matlab
    float unitfreq = 30.0 / 4096.0; // (30 samples/second)/4096 samples = 0.0073 Hz increase per index
    //printf("unit frequency: %f\n", unitfreq);
    float searchspan = 1.4*RR/unitfreq; // expecting our peak at about k = 59, but going a little beyond in case
    //printf("Search span: %f\n", searchspan);
    float H1 = 0;
    //todo: assert
    for(int k = 4; (k <= (int)searchspan) && (k < 4096); k++) {
        if(H1 < output[k]) {
            H1 = output[k];
        }
    }

    //printf("H1 component: %f\n", H1);
    //printf("Sample 1 H1/DC mbed: %f\n", H1/DC);
    //pc.printf("H1/DC as percent: %f \n", (H1/DC)*100.00);
#ifdef DEBUG
    pc.printf("H1/DC as int: %d\n", (int)((H1/DC)*100.00));
#endif
    int ratio = (int)(100.00*H1/DC);
    return ratio;
}

#define kTransferSize (32 * 1024)
#define kMaxLoops (1024 * 1024)
char transfer_space[kTransferSize];
int resultmountblue()
{
#ifdef DEBUG
    pc.printf("\nENTER RESULT BLUE:");
#endif
    whitesd = 1;
    bluesd = 0;
    SDFileSystem* sdblue_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PB_4, "sdblue");
    SDFileSystem& sdblue = *sdblue_ptr;
    if(sdblue.card_present()) { //todo: should be able to remove
#ifdef DEBUG
        pc.printf("Card present\n");
#endif
    } else {
#ifdef DEBUG
        pc.printf("no card\n");
#endif
    }
    int sdblue_result = sdblue.mount();
#ifdef DEBUG
    pc.printf("result of sdblue mount is %d\n", sdblue_result);
#endif
    sdblue.unmount();
    delete sdblue_ptr;
    //printf("\nEXIT RESULT BLUE:");
    if(sdblue_result == 0) {
        return 0; //good
    } else {
        return -1; //bad
    }

}
int resultmountwhite()
{
#ifdef DEBUG
    pc.printf("\nENTER RESULT WHITE:");
#endif
    bluesd = 1;
    whitesd = 0;
    SDFileSystem* sdwhite_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PA_4, "sdwhite");
    SDFileSystem& sdwhite = *sdwhite_ptr;
    if(sdwhite.card_present()) {
#ifdef DEBUG
        pc.printf("Card present \n");
#endif
    } else {
#ifdef DEBUG
        pc.printf("no card \n");
#endif
    }
    int sdwhite_result = sdwhite.mount();
#ifdef DEBUG
    pc.printf("result of sdwhite mount is %d\n", sdwhite_result);
#endif
    sdwhite.unmount();
    delete sdwhite_ptr;
    //printf("\nEXIT RESULT WHITE:");
    if(sdwhite_result == 0) {
        return 0; //good
    } else {
        return -1; //bad
    }
}

void whipewhite(void)
{
    bluesd = 1;
    whitesd = 0;
    SDFileSystem* sdwhite_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PA_4, "sdwhite");
    SDFileSystem& sdwhite = *sdwhite_ptr;
    if(sdwhite.card_present()) {
#ifdef DEBUG
        pc.printf("Card present \n");
#endif
    } else {
#ifdef DEBUG
        pc.printf("no card \n");
#endif
    }
    int sdwhite_result = sdwhite.mount();
#ifdef DEBUG
    pc.printf("result of sdwhite mount is %d\n", sdwhite_result);
    pc.printf("Writing to card...");
#endif
    FILE *out2 = fopen("/sdwhite/sdwhitewhatfuck9_20_17.txt", "w"); //todo: real file names
    if (out2 != NULL) {
        //fprintf(out2, "WHIPE,");
        fprintf(out2, "");
        fclose(out2);
#ifdef DEBUG
        pc.printf("success!\n"); //todo delete file to save space.
#endif
    } else {
#ifdef DEBUG
        pc.printf("failed!\n"); //todo dont end program if failed. show on screen it failed
#endif
    }
    sdwhite.unmount();
    delete sdwhite_ptr;
}
void writewhite(int ratio_flowNEG, int ratio_flowPOS, int ratio_pressure)
{
#ifdef DEBUG
    pc.printf("\nENTER WRITE WHITE:");
#endif
    const char mrnformat[] = "%c%c%c%c%c%c%c%c%c%c,"; //todo: figure this out
    const char settingsfileformat[] = "%c%c%c%c,";
    const char ratioformat[] = "%d,";
    const char dateformat[] = "%c%c%c%c%c%c%c%c%c%c%c%c,"; //ex) char curr_time[]="170424120643";
    //char mrntest[] = "mrntest";
    int i=0;
    while(resultmountwhite() == -1) {
        if(i>10) {
            resultmountblue(); //todo: changed from if(resultmountblue() == 0 to resultmount blue. Maybe change back
            if(resultmountwhite() == 0) {
                break;
            } else {
                return;
            }
        }
        //  printf("\nWRITEWHITE ITERATION %d:", i);
        i++;
        wait(1);
    }
    bluesd = 1;
    whitesd = 0;
    SDFileSystem* sdwhite_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PA_4, "sdwhite");
    SDFileSystem& sdwhite = *sdwhite_ptr;
    if(sdwhite.card_present()) {
#ifdef DEBUG
        pc.printf("Card present \n");
#endif
    } else {
#ifdef DEBUG
        pc.printf("no card \n");
#endif
    }
    int sdwhite_result = sdwhite.mount();
#ifdef DEBUG
    pc.printf("result of sdwhite mount is %d\n", sdwhite_result);
    pc.printf("Writing to card...");
#endif
    FILE *out2 = fopen("/sdwhite/sdwhitewhatfuck9_20_17.txt", "a"); //todo: real file names
    if (out2 != NULL) {
        //fprintf(out2, "%c%c%c,", ch_rhve[0], ch_rhve[1], ch_rhve[2]);wont print absolutlety do not understand
        fprintf(out2, "\n");
        fprintf(out2, "settingsERcnt:%d", settingsERcnt);
        fprintf(out2, "resppeepconversion:%d", resppeepconversion);
        fprintf(out2, "commcheckcount:%d", commcheckcount);
        commcheckcount = 0;
        fprintf(out2, "parseconversion:%d", parseconversion);
        fprintf(out2, "wellintrpt:%d:%d", wellintrpt, ib_datacollectionwentwell);
        fprintf(out2, mrnformat, s_MRN[0], s_MRN[1], s_MRN[2], s_MRN[3], s_MRN[4], s_MRN[5], s_MRN[6], s_MRN[7], s_MRN[8], s_MRN[9]);
        fprintf(out2, ratioformat, ratio_flowNEG);
        fprintf(out2, ratioformat, ratio_flowPOS);
        fprintf(out2, ratioformat, ratio_pressure);
        fprintf(out2, dateformat, rawventdata_settings[7], rawventdata_settings[8], rawventdata_settings[9], rawventdata_settings[10], rawventdata_settings[11], rawventdata_settings[12], rawventdata_settings[13], rawventdata_settings[14], rawventdata_settings[15], rawventdata_settings[16], rawventdata_settings[17], rawventdata_settings[18]);
        for(int i=39; i<103; i=i+4) {//Begin:39, Middle:106: End: 145
            fprintf(out2, settingsfileformat, rawventdata_settings[i], rawventdata_settings[i+1], rawventdata_settings[i+2], rawventdata_settings[i+3]);
        }
        for(int i=106; i<142; i=i+4) {//Begin:39, Middle:106: End: 145
            fprintf(out2, settingsfileformat, rawventdata_settings[i], rawventdata_settings[i+1], rawventdata_settings[i+2], rawventdata_settings[i+3]);
        }
        fprintf(out2, "PA1,");
        for(int i=0; i<4096; i++) {
            fprintf(out2, "%f,", parsedchannelzero[i]);
        }
        fprintf(out2, "PA2,");
        for(int i=0; i<4096; i++) {
            fprintf(out2, "%f,", parsedchanneltwo[i]);
        }
        fprintf(out2, "PR1N,");
        for(int i=0; i<350; i++) {
            fprintf(out2, "%f,", processedchannelzeroNEG[i]);
        }

        fprintf(out2, "PR1P,");
        for(int i=0; i<350; i++) {
            fprintf(out2, "%f,", processedchannelzeroPOS[i]);
        }
        fprintf(out2, "PR2,");
        for(int i=0; i<350; i++) {
            fprintf(out2, "%f,", processedchanneltwo[i]);
        }
        fprintf(out2, "END,");
        fclose(out2);
#ifdef DEBUG
        pc.printf("success!\n"); //todo delete file to save space.
#endif
    } else {
#ifdef DEBUG
        pc.printf("failed!\n"); //todo dont end program if failed. show on screen it failed
#endif
    }
    sdwhite.unmount();
    delete sdwhite_ptr;
}
void transfer_file()
{
    // printf("\nENTER TRANSFERFILE:");
    int i=0;
    while(resultmountblue() == -1) {
        if(i>10) {
            resultmountwhite(); //todo: changed from if(resultmountblue() == 0 to resultmount blue. Maybe change back
            if(resultmountblue() == 0) {
                break;
            } else {
                //           printf("\nTRANSFER FAILED TO MOUNT EXTERNAL");
                return;
            }
        }
        // printf("\nTRANSFERRESULTBLUE ITERATION %d:", i);
        i++;
        wait(1);
    }
    i=0;
    while(resultmountwhite() == -1) {
        if(i>10) {
            resultmountblue(); //todo: changed from if(resultmountblue() == 0 to resultmount blue. Maybe change back
            if(resultmountwhite() == 0) {
                break;
            } else {
                //       printf("\nTRANSFER FAILED TO MOUNT INTERNAL");
                return;
            }
        }
        //  printf("\nWRITEWHITE ITERATION %d:", i);
        i++;
        wait(1);
    }

    bluesd = 1;
    whitesd = 0;
    for(size_t i = 0; i < kMaxLoops; i++) {
#ifdef DEBUG
        pc.printf("We are on loop iteration %u\n", i);
#endif
        whitesd=0;
        bluesd=1;
        SDFileSystem* sdwhite_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PA_4, "sdwhite");
        SDFileSystem& sdwhite = *sdwhite_ptr;
        if (sdwhite.card_present()) { //todo: remove
#ifdef DEBUG
            pc.printf("Card sdwhite is present!\n");
#endif
        } else {
#ifdef DEBUG
            pc.printf("Card sdwhite is not presetn!\n");
#endif
        }
        int sdwhite_result = sdwhite.mount();
#ifdef DEBUG
        pc.printf("result of sd white mount was %d\n", sdwhite_result);
#endif
        FILE *read = fopen("/sdwhite/sdwhitewhatfuck9_20_17.txt", "r");
        if (read == NULL) {
#ifdef DEBUG
            pc.printf("Not able to open read file\n");
#endif
            break;
        }
        fseek(read, i*kTransferSize, SEEK_SET);
        size_t num_bytes_read = fread(transfer_space, sizeof(char), kTransferSize, read);
        fclose(read);
        sdwhite.unmount();
        delete sdwhite_ptr;

        whitesd=1;
        bluesd=0;
        SDFileSystem* sdblue_ptr = new SDFileSystem(PA_7, PA_6, PA_5, PB_4, "sdblue");
        SDFileSystem& sdblue = *sdblue_ptr;
        int sdblue_result = sdblue.mount();
#ifdef DEBUG
        pc.printf("result of sd blue mount was %d\n", sdblue_result);
#endif
        FILE *write = fopen("/sdblue/file_out.txt", "w");
        if (write == NULL) {
#ifdef DEBUG
            pc.printf("Not able to open write file\n");
#endif
            break;
        }
        fseek(write, i*kTransferSize, SEEK_SET);
        size_t num_bytes_write = fwrite(transfer_space, sizeof(char), num_bytes_read, write);
        fclose(write);
        sdblue.unmount();
        delete sdblue_ptr;

        if(num_bytes_read < kTransferSize) {
            break;
        }
    }

}

int updateventstatus(void)
{
//return == 0; No communication
//return == 1; In standby
//return == 2; In collection
    bufferselect = 0; //future versions abort by esc returns an error.
    const char esc[] = {0x1B};
    sendcommand(esc,1);
    const char rcty[] = {'R', 'C', 'T', 'Y', '1', 'C', 0x04};
    const char readalarmstandby[] = {'R', 'A', 'D', 'A', 'A', '5', '7', 0x04}; //read acquired data
    int lenreadalarmstandby = 8;
    int lenrcty = 7;
    wait(1);//todo: remove
    bufferselect = 2;
    interruptdatacount_settings = 0;
    rawventdata_settings[11] = 'Z';
    rawventdata_settings[12] = 'Z';
    rawventdata_settings[13] = 'Z';
    rawventdata_settings[14] = 'Z';
    sendcommand(rcty, lenrcty); //Servo-i029<04>
    //pc.printf("START:%d\n", interruptdatacount_settings);
    sendcommand(readalarmstandby, lenreadalarmstandby);
    int j = 0;
    while(interruptdatacount_settings < 15) {
        if(j>5) {
            break;
        }
        wait(1);
        j++;
    }
    s_DEBUG[0] = rawventdata_settings[11];
    s_DEBUG[1] = rawventdata_settings[12];
    s_DEBUG[2] = rawventdata_settings[13];
    s_DEBUG[3] = rawventdata_settings[14];
#ifdef DEBUG
    pc.printf("ALARM ERROR: %c%c%c%c\n", rawventdata_settings[11], rawventdata_settings[12], rawventdata_settings[13], rawventdata_settings[14]);
#endif
    if(rawventdata_settings[11] == 'E' && rawventdata_settings[12] == 'R' && rawventdata_settings[13] == '1' && rawventdata_settings[14] == '7') {
#ifdef DEBUG
        pc.printf("FAILED: STANDY\n");
#endif
        return 1;
    } else if(rawventdata_settings[11] == 'E' && rawventdata_settings[12] == 'R' && rawventdata_settings[13] == '1' && rawventdata_settings[14] == '6') {
#ifdef DEBUG
        pc.printf("PASSED: COLLECTION\n");
#endif
        return 2;
    } else {
#ifdef DEBUG
        pc.printf("FAILED: NOCOMMS\n");
#endif
        return 0;
    }
}

/*void setgaugetest()
{
    //Writes most recent Enqueued h1dc value to gauge.
    //Gauge runs from 15% to 75%. Need to cutoff h1dc values above and below these thresholds.
    //Also subtract 15 because gauge technically runs from 0-60. it is just displayed as 15-75
    //printf("Enter Set Gage\n");
    //int tail_copy=h1dcqueue->tail; //Unnecessary
    int h1dcscaledtogauge=0;
    h1dcscaledtogauge=setgaugetemptest;
    if(h1dcscaledtogauge<15) {
        h1dcscaledtogauge=0;
    } else if(h1dcscaledtogauge>75) {
        h1dcscaledtogauge=60;
    } else {
        h1dcscaledtogauge=h1dcscaledtogauge-15;
    }
    //todo: assert h1dcscaledtogauge in range expected. Doesn't crash tho, Just causes red boxes.
    lcd4d.genieWriteObject(GENIE_OBJ_ANGULAR_METER,0,h1dcscaledtogauge);
    //printf("h1dcscaledtogauge: %d\n", h1dcscaledtogauge);
    //test code run in main
    //for(int i = 0; i<100; i++){
    //enQueue(h1dcqueue, i);
    //setgauge();
    //printf("h1dc: %d\n", i);
    //}
}*/


int MRNConfirmed = 0;
//char s_MRN[]="          "; // 10 spaces. moved to top
volatile int MRNcounter = 0; //used in mygenieeventhandler to track number entered and in main to determine when to detatch eventhandler.
#define MRNarraylength (10)
void myGenieEventHandler(void)
{
    genieFrame Event;
    lcd4d.genieDequeueEvent(&Event);
    char c_temp;
    char c_blank=' ';
    //event report from an object
    if(Event.reportObject.cmd == GENIE_REPORT_EVENT) {
        /*
        for example here we check if we received a message from 4dbuttons objects
        the index is the button number, refer to the 4dgenie project to know the index
        */
        if (Event.reportObject.object == GENIE_OBJ_KEYBOARD) {              // If the Reported Message was from a button
            if (Event.reportObject.index == 0) {
                //printf("Keyboard Button pressed!\n");
                c_temp=lcd4d.genieGetEventData(&Event);
#ifdef DEBUG
                pc.putc(c_temp);
#endif
                //pc.printf("\n");
                if((c_temp == 0x30) || (c_temp == 0x31) || (c_temp == 0x32) || (c_temp == 0x33) || (c_temp == 0x34) || (c_temp == 0x35) || (c_temp == 0x36) || (c_temp ==0x37) || (c_temp ==0x38) || (c_temp == 0x39)) {
                    if(MRNcounter<MRNarraylength) {
                        //printf("Digit\n");
                        s_MRN[MRNcounter] = c_temp;
                        MRNcounter++;
                    }
                    //todo: else write to screen error: expected 10 digits.
                    //lcd4d.genieWriteStr(0,s_MRN);
                } else if(c_temp == 0x64) { //delete
                    //printf("Delete\n");
                    if(MRNcounter>0) {
                        MRNcounter--;
                    }
                    s_MRN[MRNcounter] = c_blank;
                    //lcd4d.genieWriteStr(0,s_MRN);
                } else if(c_temp == 0x61) { //accept
                    if(MRNcounter == 10) { //Should be true or else not valid MRN.
                        //printf("Confirm\n");
                        MRNConfirmed = 1;
                    }
                    //lcd4d.genieWriteStr(0,s_MRN);
                }
            }
        }
    }
}

Timer t_curveruntime;
//Aisling's Functions
Timer t_flashdecision;
const int h1dcqueuesize = 7;
//Tail and Head both start at idx 0.
//Except for initial condition. Tail is always equal (tracking) to the most recently enQueued value.
//After filling out 572 points in the array. Tail will start to follow one index behind head until program end.
//Consider head to be tracking the index one previously to the arrays actual beginning. Thus using (graphing) data from head+1 until  and including tail is always valid but not if head==tail (empty condition).AKA) Tail backwards until head+1.
int mod (int a, int b)
{
    int ret = a % b;
    if(ret < 0)
        ret+=b;
    return ret;
}
struct queue {
    int A[h1dcqueuesize];
    int head;
    int tail;
};
void initQueue(struct queue *q)
{
    q->tail=0;
    q->head=0;
}
int deQueue(struct queue *q)
{
    if(q->head==q->tail) { //Empty
        return -1;
    }
    q->head=(q->head+1)%h1dcqueuesize;
    return 0;
}
int enQueue(struct queue *q, int elm)
{
    int next_idx=(q->tail+1)%h1dcqueuesize;
    if(next_idx==q->head) {
        deQueue(q);
    }
    //todo: assert next idx <6.
    q->A[next_idx] = elm;
    q->tail = next_idx;
    return 0;
}
void setgauge(struct queue *q)
{
    //Writes most recent Enqueued h1dc value to gauge.
    //Gauge runs from 15% to 75%. Need to cutoff h1dc values above and below these thresholds.
    //Also subtract 15 because gauge technically runs from 0-60. it is just displayed as 15-75
    int h1dcscaledtogauge=0;
    if(q->head == q->tail) {
        return; //-1: Error empty
    }
    h1dcscaledtogauge=q->A[(q->tail)];
    if(h1dcscaledtogauge<15) {
        h1dcscaledtogauge=0;
    } else if(h1dcscaledtogauge>75) {
        h1dcscaledtogauge=60;
    } else {
        h1dcscaledtogauge=h1dcscaledtogauge-15;
    }
    lcd4d.genieWriteObject(GENIE_OBJ_ANGULAR_METER,0,h1dcscaledtogauge);
}
void flashingdecision(struct queue *h1dcqueue)
{
    int tail_copy=h1dcqueue->tail;
    int head_copy=h1dcqueue->head;
    int h1dc_copy = h1dcqueue->A[tail_copy];
    unsigned long current_mills_AC = t_flashdecision.read_ms();
    static int flash_switch=0;
    unsigned long flash_interval = 600; //ms interval
    static unsigned long previous_mills_flash=0;

    if(head_copy==tail_copy) {
        //H1dcqueue is empty. Dont run.
    } else {
        if(h1dc_copy>55) {
            if((current_mills_AC - previous_mills_flash)>=flash_interval) {
                previous_mills_flash = current_mills_AC;
                if(flash_switch==0) {
                    //printf("Flash Flash 2 red\n");
                    lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,0,1);
                    flash_switch=1;
                } else {
                    lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,0,0);
                    flash_switch=0;
                }
            }
        } else if(h1dc_copy<35) {
            if((current_mills_AC - previous_mills_flash)>=flash_interval) {
                previous_mills_flash = current_mills_AC;
                if(flash_switch==0) {
                    lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,2,1);
                    flash_switch=1;
                } else {
                    lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,2,0);
                    flash_switch=0;
                }
            }
        } else {
            lcd4d.genieWriteObject(GENIE_OBJ_USER_LED,2,0);
        }
    }
}
void printQueue(struct queue *q)
{
    pc.printf("\n");
    pc.printf("Head:%d,TaiL%d\n",q->head,q->tail);
    pc.printf("Queue:0~%d 1~%d 2~%d 3~%d 4~%d 5~%d 6~%d\n",q->A[0], q->A[1], q->A[2], q->A[3], q->A[4], q->A[5], q->A[6]);
}
void trend_realtime(struct queue *h1dcqueue)
{
    //printQueue(h1dcqueue);
    int scope1height=177; //height of scope(1) on touchscreen. can choose to keep same height for all 4 scopes.
    double h1dctopixels;
    int tail_copy=h1dcqueue->tail;
    static int plottracker12=0;
    static int plottracker24=0;
    plottracker12++;
    plottracker24++;
    double sum;
    double average;
    //pc.printf(" 12p:%d, 24p:%d", plottracker12, plottracker24);
    //One Hour Screen
    if (h1dcqueue->A[tail_copy]>75) { //set all h1s above 75 to show up as on top of the scope
        h1dctopixels=scope1height;
    } else if(h1dcqueue->A[tail_copy]<=15) { //set all h1s below 15 to show up as on bottom of scope
        h1dctopixels=0;
    } else {
        h1dctopixels=(((h1dcqueue->A[tail_copy])-15)/60.0)*scope1height; //60.0 is range of values 75%-15%=60. -15 because graph starts from 15% rather than 0%.
        h1dctopixels=floor(h1dctopixels+.5);//if it's 2.3, add .5 and round to 2 bc have 2.8 and you round down. if it's 2.8, add .5 and round to 3 bc 3.2
    }
    //printf("*h1dc:%d, 1-h1dctopixels:%f\n, ",h1dcqueue->A[tail_copy], h1dctopixels);
    lcd4d.genieWriteObject(GENIE_OBJ_SCOPE,3,h1dctopixels); //good

    //Twelve Hour Screen
    //if 4 h1/dc's have been acquired, which are averaged together to make 1 point then run
    if(plottracker12==4) {
        //pc.printf("Twelve Hour Plot Entered");
        plottracker12=0;
        //Averages last four h1/Dc values
        sum=h1dcqueue->A[tail_copy]+h1dcqueue->A[mod((tail_copy-1),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-2),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-3),h1dcqueuesize)];
        average = sum/4.0;
        if (average>75) {
            h1dctopixels=scope1height;
        } else if(average<15) {
            h1dctopixels=0;
        } else {
            h1dctopixels=((average-15)/60.0)*scope1height; //60.0 is range of values 75%-15%. -15 because graph starts from 15% rather than 0%.
            h1dctopixels=floor(h1dctopixels+.5);//if it's 2.3, add .5 and round to 2 bc have 2.8 and you round down. if it's 2.8, add .5 and round to 3 bc 3.2
        }
        //printf("*average:%f, 12-h1dctopixels:%f\n, ",average, h1dctopixels);
        lcd4d.genieWriteObject(GENIE_OBJ_SCOPE,6,h1dctopixels); //good
    }

    //24 Hour Screen
    //if 6 h1/dc's have been acquired, which are averaged together to make 1 point
    if(plottracker24==6) {
        //pc.printf("24 Hour Plot Entered");
        plottracker24=0;
        //Averages last four h1/Dc values
        sum=h1dcqueue->A[tail_copy]+h1dcqueue->A[mod((tail_copy-1),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-2),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-3),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-4),h1dcqueuesize)]+h1dcqueue->A[mod((tail_copy-5),h1dcqueuesize)];
        average=sum/6.0;
        if (average>75) {
            h1dctopixels=scope1height;
        } else if(average<15) {
            h1dctopixels=0;
        } else {
            h1dctopixels=((average-15)/60.0)*scope1height; //60.0 is range of values 75%-15%. -15 because graph starts from 15% rather than 0%.
            h1dctopixels=floor(h1dctopixels+.5);//if it's 2.3, add .5 and round to 2 bc have 2.8 and you round down. if it's 2.8, add .5 and round to 3 bc 3.2
        }
        //printf("*average:%d, 24-h1dctopixels:%d\n,",average, h1dctopixels);
        lcd4d.genieWriteObject(GENIE_OBJ_SCOPE,0,h1dctopixels); //good
    }
}

void modtest(void)
{
    pc.printf("\n");
    for(int i = 0; i<15; i++) {
        int a;
        a = i%7;
        pc.printf("%dmod7:%d ", i, a);
    }
    pc.printf("\n");

    pc.printf("\n");
    for(int i = 0; i>-15; i--) {
        int a;
        a = mod(i, h1dcqueuesize);
        pc.printf("%dmod7:%d ", i, a);
    }
    pc.printf("\n");
}
void qtst(struct queue *n)
{
    //pc.printf("\nhead:%d tail:%d", ptrtomyh1dcqueue->head, ptrtomyh1dcqueue->tail);
    //initQueue(ptrtomyh1dcqueue);
    //pc.printf("\nhead:%d tail:%d", ptrtomyh1dcqueue->head, ptrtomyh1dcqueue->tail);
    //modtest();
    t_flashdecision.start();
    initQueue(n);
    //printQueue(n);
    //for(int i = 5; i<50; i++) {
    //  enQueue(n, i);
    // printQueue(n);
    //}
    lcd4d.genieWriteObject(GENIE_OBJ_FORM,5,0);
    for(int i = 0; i<100; i++) {
        enQueue(n, i);
        setgauge(n);
        flashingdecision(n);
        trend_realtime(n);
        printf("h1dc: %d\n", i);
    }
}

int main()
{
#ifdef DEBUG
    pc.printf("___________NEW RUN ____________\n");
#endif
    lcd4d.Start();
    /*whipewhite();
    transfer_file();
    pc.printf("done");
    return 0;*/
    pc.printf("\n___________NEW RUN ____________\n");
    struct queue myh1dcqueue;
    struct queue *ptrtomyh1dcqueue = &myh1dcqueue;
    //pc.printf("\nsize of struct:%d", sizeof(myh1dcqueue)); //36
    //qtst(ptrtomyh1dcqueue);
    myled1 = 0;
    myled2 = 0;
    myled3 = 0;
    lcd4d.genieAttachEventHandler(&myGenieEventHandler);
    while(MRNConfirmed == 0) {
        lcd4d.genieWriteStr(0,s_MRN);
        wait(.2); //Visually looks better if its not flashing so much.
    }
    lcd4d.genieDetachEventHandler(&myGenieEventHandler);
    //lcd4d.genieWriteObject(GENIE_OBJ_FORM,5,0); //Goes to gauge screen.
    pb_exportcontrol.mode(PullUp);    // Use internal pullup for pushbutton
    wait(.01);    // Delay for initial pullup to take effect todo: unnecessary probabky
    vent.format(9, SerialBase::Even, 1);
    vent.attach(&Rx_Interrupt, Serial::RxIrq);
    vent.baud(9600);
    int h1dc_flowNEG = 0;
    int h1dc_flowPOS = 0;
    int h1dc_pressure = 0;
    int i_exportcontrol = 1;
    int ventstatus = 0;
    int standbycount = 0; //Need to give vent time to update settings before requesting if just left standby to collection.
    int b_alreadyongauge = 0;
    //ventstatus == 0; No communication
    //ventstatus == 1; In standby
    //ventstatus == 2; In collection
    //setprotocol();
    t_curveruntime.start();
    t_flashdecision.start();
    while(1) {
        do { //check communication
            commcheckcount++;
            ventstatus = updateventstatus();
            if(ventstatus == 0) {
                //screen: TEXT COMMS FAILED
                lcd4d.genieWriteObject(GENIE_OBJ_FORM,7,0);
                lcd4d.genieWriteStr(1,s_DEBUG);
                b_alreadyongauge = 0;
            } else if(ventstatus == 1) {
                //screen: TEXT IN STANDBY
                lcd4d.genieWriteObject(GENIE_OBJ_FORM,8,0);
                b_alreadyongauge = 0;
            } else if(ventstatus == 2) {
                //screen: Gauge
                if(b_alreadyongauge == 0) { //Flickers if do this everytime.
                    lcd4d.genieWriteObject(GENIE_OBJ_FORM,5,0);
                    b_alreadyongauge = 1;
                }
            }
            standbycount = 1; //todo: was ++. can overflow.
            i_exportcontrol = pb_exportcontrol; //need to store to int,
            if(i_exportcontrol == 0) {
                lcd4d.genieWriteObject(GENIE_OBJ_FORM,6,0); //TEXT: Writing to SD card please wait.
                transfer_file();//todo: transferfile
                i_exportcontrol = 1;
                //todo return 0 if writing sucess; transfer file must return output
            }
        } while(ventstatus != 2);
        if(standbycount > 0) {
            standbycount = 0;
            wait(3); //necessary
        }
        if(ventstatus == 1 || ventstatus == 0) { //need to check for not on standby / have comms
            //Not doing anything here yet. Just recalculate status at next iteration of while(1).
        } else if(ventstatus == 2) { //not on standby, can collect data
#ifdef DEBUG
            pc.printf("START_______\n");
#endif
            collectsettings();
            requestcurvedata();
            t_curveruntime.reset();
            t_flashdecision.reset();
            unsigned long ul_runtime = 0;
            while((interruptdatacount_curve <  rawdatasize) && ul_runtime < 150) {
	    //Run checks or wwhatever you want in here until collect enough data or havent collected enough data in time it should have taken + some.

                const char readcurve_rx[] = {'R', 'C', '1', '0', '2', '4', '0', 0x04}; //todo. I can just place this into rx_interrupt function cant I?
                int lenreadcurve_rx = 8; //same as above.
                if(ib_needmoredata) {
                    for(int i = 0; i<lenreadcurve_rx; i++) {
                        vent.putc(readcurve_rx[i]); //todo: make readcurve_rx local rather than global
                        wait(.04); //necessary or else sometimes mistake.
                    }
                    ib_needmoredata = 0;
                }

                //flashingdecision();
                ul_runtime = t_curveruntime.read();
                i_exportcontrol = pb_exportcontrol; //need to store to int,
                if(i_exportcontrol == 0) {
                    lcd4d.genieWriteObject(GENIE_OBJ_FORM,6,0); //TEXT: Writing to SD card please wait.
                    transfer_file();//todo: transferfile
                    lcd4d.genieWriteObject(GENIE_OBJ_FORM,5,0); //Goes to gauge screen.
                    //todo return 0 if writing sucess; transfer file must return output
                }
#ifdef DEBUG
                pc.printf("runtime: %lu", ul_runtime);
                pc.printf("InterruptDatacount: %d\n", interruptdatacount_curve);
#endif
            }
#ifdef DEBUG
            pc.printf("interrupt data count curveFINAL: %d\n", interruptdatacount_curve); //should be 36864 == 4096*9
            pc.printf("interrupt data count settingsFINAL: %d\n", interruptdatacount_settings); //should be less than 200
            pc.printf("Datanotoverrun?: %d\n", ib_datacollectionwentwell);
#endif
            //Done collecting raw data. Now run fuctions to parse, get H1 values, etc.
            wait(.04); //Incase vent tries to grab another point, will let us know something went wrong and below if doesnt evaluate true.
            if(interruptdatacount_curve == 36864 && ib_datacollectionwentwell) { //if broke during data collection wont equal this so dont try to process data.
                parserawdata();
                for(int i = 0; i < 4096; i++) {
                    real[i] = (parsedchanneltwo[i]-i_PEEP); //pressure number - peep
                    imag[i] = 0.00;
                }
                h1dc_pressure = processdata(processedchanneltwo);
                for(int i = 0; i < 4096; i++) {
                    if(parsedchannelzero[i] < 0) {
                        real[i] = 0.00;
                    } else {
                        real[i] = parsedchannelzero[i];
                    }
                    imag[i] = 0.00;
                }
                h1dc_flowPOS = processdata(processedchannelzeroPOS);
                for(int i = 0; i < 4096; i++) { //gold standard, May want to alllw user to choose which signal to calculate fft from in future.
                    if(parsedchannelzero[i] > 0) {
                        real[i] = 0.00;
                    } else {
                        real[i] = parsedchannelzero[i];
                    }
                    imag[i] = 0.00;
                }
                h1dc_flowNEG = processdata(processedchannelzeroNEG);
                //setgaugetemptest = h1dc_flowNEG;
                enQueue(ptrtomyh1dcqueue,h1dc_flowNEG);
                setgauge(ptrtomyh1dcqueue);
                //trend_realtime(ptrtomyh1dcqueue);
                writewhite(h1dc_flowNEG, h1dc_flowPOS, h1dc_pressure); //todo: Potentially move this above setgauge so smaller delay before flashing decision
                //setgaugetest();
#ifdef DEBUG
                pc.printf("Print please\n");
#endif
            } else {
                wellintrpt++;
#ifdef DEBUG
                pc.printf("FAILED TO GET DATA\n"); //todo: storetofile
#endif
                //wait(3); //todo: remove
            }
        }
    }
    //free(h1dcqueue);
    return 0;
}
